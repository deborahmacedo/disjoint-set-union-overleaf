\documentclass[conference]{IEEEtran}
\IEEEoverridecommandlockouts

% --- Pacotes Essenciais ---
\usepackage{cite}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{algorithmic}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{xcolor}
\usepackage[utf8]{inputenc} % Codificação para acentos e caracteres especiais
\usepackage[portuguese]{babel} % Idioma em português
\usepackage{url} % Para URLs nas referências
\usepackage{float} % Para controle de figuras (embora as imagens serão ignoradas, o pacote é útil para pseudocódigos)
\usepackage{caption} % Para a numeração de pseudocódigos
\usepackage{subcaption} % Para subfiguras

% --- Definição das Macros (simulando as figuras e pseudocódigos no texto original) ---
\newcommand{\pseudocodofindnaive}{
\begin{verbatim}
function find(x)
if parent [x] == x
  return x
else
  return find (parent [x])
\end{verbatim}
}

\newcommand{\pseudocodofindnaiveinlined}{
\begin{verbatim}
int find_set(int v) {
  if (v == parent[v])
    return v;
  return find_set(parent [v]);
}
\end{verbatim}
}

\newcommand{\pseudocodofindoptimized}{
\begin{verbatim}
int find_set(int v) {
  if (v == parent[v])
    return v;
  return parent[v] = find_set(parent[v]);
}
\end{verbatim}
}

\newcommand{\pseudocodoScanLine}{
\begin{verbatim}
(1) tratamento especial da primeira linha
(2) para i := 2 a l fazer começar
(3)   tratamento especial do primeiro pixel da linha i
(4)   para j := 2 a w fazer começar
(5)     esquerda <- FindCompress(bm[bi, j-ld]);
(6)     para cima <- FindCompress(bm[bi-1, y]);
(7)     this <- FindCompress(bm[bi, jd]);
(8)     se Oracle(esquerda, isto) então isto <- União(esquerda, isto);
(9)     se Oracle(ponta, isto) então União(ponta, isto),
(10)  fim
(11)  Aplanar(linha i)
(12) fim
\end{verbatim}
}

\newcommand{\pseudocodoMergeSquares}{
\begin{verbatim}
Entrada: Um número inteiro k e um bitmap bm de tamanho 2^k x 2^k
(1) se k=0, então retorne 
(2) li := 2^(k-1) - 1; a += 2^k;
(3) para DIR <- NW para SE faça MergeSquares(bm[DBA], k-1);
(4) para i := 0 a 2^k faça começar
(5)   esquerda: Encontrar(bm[bi, j]), direita: Encontrar(bm[i, h+j]);
(6)   se Oracle(esquerda, direita) então União(esquerda, direita),
(7) fim
(8) para i := 0 a 2^k fazer começar
(9)   up: Encontrar(bm[b/i*, 1])); down: Encontrar(km[/i", id);
(10)  se Oracle(cima, baixo) então União(cima, baixo);
(11) fim
\end{verbatim}
}

\newcommand{\kernelINITIALIZATION}{
\begin{verbatim}
1: kernel INITIALIZATION (L, step_L)
2: r <- (threadIdx.y + blockIdx.y x blockDim.y) x 2
3: c <- (threadIdx.x + blockIdx.x x blockDim.x) x 2
4: x_L <- r x step_L + c
5: L[x_L] <- x_L
\end{verbatim}
}

\newcommand{\kernelMERGE}{
\begin{verbatim}
6: kernel MERGE(I, step_I, L, step_L)
7: r <- (threadIdx.y + blockIdx.y x blockDim.y) x 2
8: c <- (threadIdx.x + blockIdx.x x blockDim.x) x 2
9: x_I <- r x step_I + c
10: x_L <- r x step_L + c
11: BS <- 0
12: if I[x_I] = 1 then BS |= 0x777
13: if I[x_I + 1] = 1 then BS |= (0x777 << 1)
14: if I[x_I + step_I] = 1 then BS |= (0x777 << 4)
15: if BS > 0 then
16:   if HasBit(BS, 0) and I[x_I - step_I - 1] then
17:     Union(L, x_L, x_L - 2 x step_L - 2)
18:   if (HasBit(BS, 1) and I[x_I - step_I]) or
19:      (HasBit (BS, 2) and I[x_I - step_I + 1]) then
20:     Union(L, x_L, x_L - 2 x step_L)
21:   if HasBit (BS, 3) and I[x_I - step_I + 2] then
22:     Union(L, x_L, x_L - 2 x step_L + 2)
23:   if (HasBit(BS, 4) and I[x_I - 1]) or
24:      (HasBit(BS, 8) and I[x_I + step_I - 1]) then
25:     Union (L, x_L, x_L - 2)
\end{verbatim}
}

\newcommand{\kernelCOMPRESSION}{
\begin{verbatim}
26: kernel COMPRESSION(L, step_L)
27: r <- (threadIdx.y + blockIdx.y x blockDim.y) x 2
28: c <- (threadIdx.x + blockIdx.x x blockDim.x) x 2
29: x_L <- r x step_L + c
30: Compress (L, x_L)
\end{verbatim}
}

\newcommand{\kernelFINALDELABELLING}{
\begin{verbatim}
31: kernel FINALLABELING(I, step_I, L, step_L)
32: r <- (threadIdx.y + blockIdx.y x blockDim.y) x 2
33: c <- (threadIdx.x + blockIdx.x x blockDim.x) x 2
34: x_I <- r x step_I + c
35: x_L <- r x step_L + c
36: label <- L[x_L] + 1
37: L[x_L] <- label x I[x_I]
38: L[x_L + 1] <- label x I[x_I + 1]
39: L[x_L + step_L] <- label x I[x_I + step_I]
40: L[x_L + step_L + 1] <- label x I[x_I + step_I + 1]
\end{verbatim}
}

\newcommand{\pseudocodoKruskal}{
\begin{verbatim}
1: A = 0
2: for each vertex v in G.V
3:   MAKE-SET(v)
4: sort the edges of G.E into
   nondecreasing order by weight w
5: for each edge (u, v) in G.E, taken in
   nondecreasing order by weight
6:   If FIND-SET(u) != FIND-SET(v)
7:     A = A U {(u, v)}
8:     UNION(u, v)
9: return A
\end{verbatim}
}

\newcommand{\pseudocodoNeuroKruskal}{
\begin{verbatim}
function NEUROSEQKRUSKAL(graph)
edgesSorted <- NeuroSort(graph.edges)
  |> or NeuroRadixSort
mstEdges <- []
for (w, u, v) in edgesSorted do
  |> batch submit
  if NeuroUnionFind([ (w, u, v) ]) then
    return mstEdges
  end if
end for
end function
\end{verbatim}
}

\newcommand{\pseudocodoGK}{
\begin{verbatim}
Require: Initial graph H=(V,E'), E' in E(G), array of edges R in particular order
1: for each edge e in R do
2:   if E(H) U {e} is acyclic then
3:     E(H) <- E(H) U {e}
4:     if H is spanning tree then
5:       return H
\end{verbatim}
}

% --- Conteúdo do arquivo myrefs.bib (23 Referências Completas) ---
% Este bloco DEVE vir antes de \maketitle para a formatação correta.
\usepackage{filecontents}
\begin{filecontents*}{myrefs.bib}
@article{chargueraud2019verifying,
author={A. Charguéraud e F. Pottier},
journal={Journal of Automated Reasoning},
title={Verifying the correctness and amortized complexity of a union-find implementation in separation logic with time credits},
year={2019},
volume={62},
number={3},
pages={331-365},
month={mar.}
}

@article{shen2023study,
author={Z. Shen, R. Li e J. Shi},
journal={Journal of Big Data and Computing},
title={A study of disjoint set union in programming competitions},
year={2023},
volume={1},
number={4}
}

@article{chen2025hierarchical,
author={L. Chen et al.},
journal={Data Science and Engineering},
title={Hierarchical isomerism distributed equivalent union find for billion-scale disjoint sets: a case study},
year={2025},
month={jun.},
note={Online]. DOI: 10.1007/s41019-025-00287-w}
}

@article{goel2019disjoint,
author={A. Goel, S. Khanna, D. H. Larkin e R. E. Tarjan},
journal={arXiv preprint arXiv:1912.00067},
title={Disjoint set union with randomized linking},
year={2019}
}

@inproceedings{alstrup2005union,
author={S. Alstrup, I. L. Gørtz, T. Rauhe, M. Thorup e U. Zwick},
booktitle={Proc. 32nd International Colloquium on Automata, Languages and Programming (ICALP)},
title={Union-find with constant time deletions},
year={2005},
address={Lisboa},
pages={78-89}
}

@inproceedings{patwary2010experiments,
author={M. M. A. Patwary, J. Blair e F. Manne},
booktitle={Experimental Algorithms},
title={Experiments on union-find algorithms for the disjoint-set data structure},
year={2010},
address={Berlin, Heidelberg: Springer}
}

@article{jayanti2021concurrent,
author={S. V. Jayanti e R. E. Tarjan},
journal={Distributed Computing},
title={Concurrent disjoint set union},
year={2021},
volume={34},
pages={413-436}
}

@article{griffiths2024union,
author={S. J. Griffiths e D. E. Browne},
journal={arXiv preprint arXiv:2306.09767},
title={Union-find quantum decoding without union-find},
year={2024}
}

@misc{professorferretto_diferenca,
author = {{Professor Ferretto}},
title = {Diferença e complementar},
howpublished = {Blog do Ferretto},
note = {Disponível em: \url{https://blog.professorferretto.com.br/diferenca-e-complementar}. [Acesso em: 01 dez. 2025]}
}

@misc{sambaiz_article390,
author = {Sambaiz},
title = {Article 390},
howpublished = {Sambaiz.net},
note = {Disponível em: \url{https://www.sambaiz.net/en/article/390/}. [Acesso em: 01 dez. 2025]}
}

@misc{algocoding_unionfind,
author = {Algocoding},
title = {Union-Find data structure - disjoint set data structure},
howpublished = {Algocoding},
year = {2014},
month = {set.},
day = {19},
note = {Disponível em: \url{https://algocoding.wordpress.com/2014/09/19/union-find-data-structure-disjoint-set-data-structure/}. [Acesso em: 01 dez. 2025]}
}

@misc{takeuforward_dsu,
author = {{Take U Forward}},
title = {Disjoint set union by rank | union by size path compression},
howpublished = {takeuforward.org},
note = {Disponível em: \url{https://takeuforward.org/data-structure/disjoint-set-union-by-rank-union-by-size-path-compression-g-46/}. [Acesso em: 01 dez. 2025]}
}

@inproceedings{chen2023analysis,
author={J. Chen},
title={The analysis and application of Prim algorithm, Kruskal algorithm, Boruvka algorithm},
booktitle={Proceedings of the 5th International Conference on Computing and Data Science},
year={2023}
}

@article{ihsan2021non,
author={M. Ihsan, D. Suhaimi, M. Ramli, S. M. Yuni, \& I. Maulidi},
title={Non-perfect maze generation using Kruskal algorithm},
journal={Jurnal Natural},
year={2021},
volume={21},
number={1}
}

@article{chong2024pipelining,
author={Y. H. Chong, P. Qu, Y. Li, \& Y. Zhang},
title={Pipelining Kruskal's: A Neuromorphic Approach for Minimum Spanning Tree},
journal={arXiv:2505.10771v2},
year={2024}
}

@inproceedings{wang2021fast,
author={Y. Wang, S. Yu, Y. Gu, \& J. Shun},
title={Fast Parallel Algorithms for Euclidean Minimum Spanning Tree and Hierarchical Spatial Clustering},
booktitle={SIGMOD '21},
year={2021}
}

@inproceedings{bossek2024generalised,
author={J. Bossek, \& C. Grimme},
title={Generalised Kruskal Mutation for the Multi-Objective Minimum Spanning Tree Problem},
booktitle={GECCO '24},
year={2024}
}

@misc{cp-algorithms,
author = {{CP-Algorithms}},
title = {Disjoint set union},
howpublished = {CP-Algorithms},
note = {Disponível em: \url{https://cp-algorithms.com/data\_structures/disjoint\_set\_union.html}. [Acesso em: 01 dez. 2025]},
year = {2025}
}

@article{fiorio1996linear,
author={C. Fiorio e J. Gustedt},
title={Two linear time Union-Find strategies for image processing},
journal={Theor. Comput. Sci.},
year={1996},
volume={154},
number={2},
pages={165-181},
doi={10.1016/0304-3975(94)00262-2}
}

@article{allegretti2020optimized,
author={S. Allegretti, F. Bolelli, e C. Grana},
title={Optimized Block-Based Algorithms to Label Connected Components on GPUs},
journal={IEEE Trans. Parallel Distrib. Syst.},
year={2020},
volume={31},
number={2},
pages={423-438},
month={fev.},
doi={10.1109/TPDS.2019.2934683}
}

@article{dubey2025advancements,
author={S. Dubey, P. Yadav, S. Pandey, e N. K. Pandey},
title={Advancements in Image Processing: Exploring Emerging Technologies and Research Opportunities},
journal={Int. J. Eng. Technol. Manage. Res.},
year={2025},
volume={12},
number={5},
pages={61-65},
month={maio},
doi={10.29121/ijetmr.v12.i5.2025.1616}
}

@misc{clarivate_wos,
author={Clarivate},
title={Web of Science Platform},
note={Disponível em: \url{https://clarivate.com/academia-government/scientific-and-academic-research/research-discovery-and-referencing/web-of-science/}. Acesso em: 04 dez. 2025}
}

@misc{elsevier_scopus,
author={Elsevier},
title={Scopus},
note={Disponível em: \url{https://www.elsevier.com/products/scopus}. Acesso em: 04 dez. 2025}
}
\end{filecontents*}

% --- Bloco de Autores (SIMULANDO LAYOUT DE TRÊS COLUNAS NA PÁGINA 1) ---
\author{
    \parbox{\linewidth}{\centering
        1\textsuperscript{st} Déborah Macedo \\
        \textit{Instituto Metrópole Digital (of Aff.)} \\
        \textit{Universidade Federal do Rio Grande do Norte (of Aff.)} \\
        Natal, Brasil \\
        deborahkmacedo@gmail.com
    }
    \and
    \parbox{\linewidth}{\centering
        2\textsuperscript{nd} Júlia Lima dos Santos \\
        \textit{Instituto Metrópole Digital (of Aff.)} \\
        \textit{Universidade Federal do Rio Grande do Norte (of Aff.)} \\
        Natal, Brasil \\
        liaju1909@gmail.com
    }
    \and
    \parbox{\linewidth}{\centering
        3\textsuperscript{rd} Rayssa Cavalcante \\
        \textit{Instituto Metrópole Digital (of Aff.)} \\
        \textit{Universidade Federal do Rio Grande do Norte (of Aff.)} \\
        Natal, Brasil \\
        Rayssa.beatriz1205@gmail.com
    }
}


\begin{document}

\title{Conjuntos Disjuntos}

\maketitle 

% --- ABSTRACT E KEYWORDS EM PORTUGUÊS ---
\begin{abstract}
\textbf{Resumo}- A estrutura de dados Conjuntos Disjuntos (Disjoint Set Union DSU), também conhecida como Union-Find, é uma ferramenta algorítmica fundamental na Ciência da Computação para gerenciar e manipular partições dinâmicas de elementos, garantindo que a intersecção entre quaisquer dois conjuntos seja nula. O DSU se destaca pela eficiência operacional, centrada nas operações Find, que identifica o representante canônico de um conjunto, e Union, que combina dois conjuntos. Para alcançar um desempenho em larga escala, o DSU emprega otimizações cruciais, como o Union by Rank/Size e a Path Compression (compressão de caminho). A combinação dessas heurísticas resulta em uma complexidade de tempo amortizada notavelmente baixa, onde $\alpha$ é a função inversa de Ackermann, garantindo sua escalabilidade em cenários com milhões de dados e em ambientes paralelos.
\end{abstract}

\begin{IEEEkeywords}
Conjuntos Disjuntos (DSU), Union-Find, Estrutura de Dados, Partições Dinâmicas, Operação Find (Busca), Operação Union (União), Representante Canônico, União por Rank/Tamanho, Compressão de Caminho, Complexidade de Tempo Amortizada, Função Inversa de Ackermann, Escalabilidade.
\end{IEEEkeywords}

% --- ABSTRACT E KEYWORDS EM INGLÊS ---
\begin{abstract}
\textbf{Abstract}- The Disjoint Set Union (DSU) data structure, also known as Union-Find, is a fundamental algorithmic tool in Computer Science for managing and manipulating dynamic partitions of elements, ensuring that the intersection between any two sets is null. DSU stands out due to its operational efficiency, centered on the Find operation, which identifies the canonical representative of a set, and the Union operation, which combines two sets. To achieve large-scale performance, DSU employs crucial optimizations such as Union by Rank/Size and Path Compression. The combination of these heuristics results in a remarkably low amortized time complexity, where $\alpha$ is the inverse Ackermann function, guaranteeing its scalability in scenarios involving millions of data points and in parallel environments.
\end{abstract}

\begin{IEEEkeywords}
Disjoint Set Union (DSU), Union-Find, Data Structure, Dynamic Partitions, Find Operation, Union Operation, Canonical Representative, Union by Rank/Size, Path Compression, Amortized Time Complexity, Inverse Ackermann Function, Scalability.
\end{IEEEkeywords}

\section{INTRODUÇÃO}

Os **Conjuntos Disjuntos** são coleções que não compartilham elementos, ou seja, sua interseção é nula. Também chamados na Ciência da Computação de **Union-Find** ou **Disjoint Set Union (DSU)**. A estrutura de dados DSU, também referida como Union-Find, é definida fundamentalmente como uma ferramenta algorítmica para gerir uma coleção de conjuntos dinâmicos e não sobrepostos.

Segundo Patwary, Blair e Manne \cite{patwary2010experiments}, o seu propósito central é manter uma partição de um universo finito, permitindo a execução eficiente de operações que modificam a estrutura dos conjuntos ou consultam a pertença dos elementos. Em contextos mais recentes e complexos, como o processamento paralelo, a definição estende-se para garantir a consistência de dados em ambientes de memória compartilhada, onde múltiplos processos podem aceder à estrutura simultaneamente \cite{jayanti2021concurrent}. São conceitos semelhantes e intimamente relacionados. O Union Find é a estrutura de dados que resolve as operações do Disjoint Set.

Esses conceitos estão profundamente conectados: enquanto os Conjuntos Disjuntos definem o problema de particionamento, o DSU é a estrutura de dados que proporciona a solução para esse problema.

A DSU se destaca pela eficiência das suas operações principais, leva também o nome de Union-Find devido as suas principais operações: a União dos conjuntos e a Busca de pertencimento de um elemento \cite{shen2023study}.

Atualmente, há um grande fluxo de dados e informações, e isso cresce a cada ano, uma aplicação que vêm do uso de DSU é o paralelismo e a grande escalabilidade deles, como no caso de estudo que Chen et al. propuseram um algoritmo Union Find distribuído, o HIDE, que alcança alta eficiência em grafos de larga escala \cite{chen2025hierarchical}.

---

\section{CONJUNTOS DISJUNTOS E PARTIÇÕES}

A teoria dos conjuntos disjuntos fundamenta problemas que exigem a separação de elementos em subconjuntos mutuamente exclusivos, constituindo uma partição do conjunto universo. O algoritmo Union-Find foi originalmente proposto "para gerenciar relações entre classes de equivalência", indicando que sua motivação primária reside na representação de grupos que, por definição, não se sobrepõem. Matematicamente, o DSU opera sobre um conjunto universo com elementos distintos, mantendo uma partição dinâmica. A propriedade central deste domínio é a disjunção, onde dois conjuntos são disjuntos se a interseção entre eles for o conjunto vazio \cite{patwary2010experiments}.

Sob a ótica da estrutura de dados, a validade desta coleção como partição é assegurada pelo uso de **identificadores canônicos**. Patwary, Blair e Manne \cite{patwary2010experiments} explicam que cada subconjunto é identificado por um "representante único", garantindo que não haja ambiguidade sobre o pertencimento de um elemento. Para sustentar essa lógica, a representação interna geralmente adota uma abordagem de **floresta de árvores enraizadas**. Nesta topologia, cada conjunto corresponde a uma árvore onde "cada nó contém um ponteiro para o seu pai e a raiz da árvore aponta para si mesma" \cite{patwary2010experiments}, atuando a raiz como o identificador do conjunto.

O DSU utiliza, internamente, uma estrutura formada por árvores. Cada conjunto disjunto é representado por uma árvore cujo nó raiz funciona como representante do conjunto. Os elementos representativos "são organizados em uma estrutura de árvore... o conjunto ao qual qualquer elemento pertence pode ser determinado rapidamente" \cite{shen2023study}. Tal estrutura permite economia de espaço e rapidez nas consultas, uma vez que cada nó armazena apenas uma referência para seu pai.

Ademais, temos que "cada elemento recebe um identificador único... Esses conjuntos podem ser fundidos dinamicamente" \cite{shen2023study}, reforçando que os conjuntos são maleáveis e podem se adaptar conforme surgem novas relações.

A dinâmica da partição evolui através de operações que alteram a topologia dos conjuntos sem violar a propriedade de disjunção. O ciclo de vida da estrutura é descrito através de três operações fundamentais \cite{patwary2010experiments}:

\begin{enumerate}
    \item **Criação (\texttt{MAKE\_SET(x)}):** O estado inicial assume que cada elemento $x$ começa em seu próprio conjunto unitário (singleton), onde o próprio $x$ é o representante.
    \item **Consulta (\texttt{FIND(x)}):** O algoritmo navega na estrutura hierárquica para retornar o representante do conjunto que contém $x$, permitindo a verificação de equivalência entre elementos.
\item **Fusão (\texttt{UNION(x,y)}):** A operação funde os conjuntos disjuntos que contém $x$ e $y$ em uma nova entidade única, reduzindo a cardinalidade total da coleção $S$.
\end{enumerate}

> **Função Find (Ingênua)**
> \pseudocodofindnaive

É importante notar que essa evolução segue regras estritas de monotonicidade. É destacada uma invariante essencial para a correção de algoritmos, especialmente em contextos paralelos: a partição evolui através da fusão; um conjunto nunca é dividido. Assim, em qualquer instante, a estrutura deve refletir uma partição válida, impondo restrições significativas sobre o acesso e modificação de memória concorrente \cite{jayanti2021concurrent}.

---

\section{OPERAÇÕES FUNDAMENTAIS}

Há três operações fundamentais no DSU: a criação de um conjunto com apenas um elemento, a união dos conjuntos e a busca por um elemento pertencente aos conjuntos.

\subsection{A. Makeset}

É a criação de um conjunto com apenas um elemento, o **singleton**, a inicialização do conjunto. Cada elemento começa como um conjunto separado de um único nó que também é a sua raiz \cite{goel2019disjoint}, pois pode garantir a formação correta e manipulação dos conjuntos disjuntos.

\subsection{B. Union}

A **União dos Conjuntos** recebe os elementos dos conjuntos e os une em um único conjunto. Por ser uma estrutura de dados e ser representada na forma de árvores, vai haver uma reorganização para uma única árvore que representará a união dos conjuntos.

A União da DSU possui variações a fim de otimizar essa operação, o ligamento por rank e por tamanho, essa técnica reduz as alturas das árvores tornando as operações seguintes mais eficientes:

*   **Union by rank:** Cada conjunto tem um valor "rank", que geralmente se refere à altura da árvore, e aquele de menor rank é unido ao de maior. Caso o rank seja igual, um se torna filho do outro, e o novo rank é incrementado.
*   **Union by size:** Ao invés de usar o rank, usa-se o tamanho (número de nós). A árvore menor é unida à maior.

Para cada um desses métodos, será necessário o armazenamento de alguns dados como as alturas das árvores e dos nós delas \cite{chen2025hierarchical}.

\subsection{C. Find}

A operação \texttt{Find(x)} irá procurar a qual árvore o elemento pertence, sendo fundamental para identificar a qual conjunto ele pertence e assim realizar as demais operações de forma mais eficiente.

Essa operação irá seguir o ponteiro do nó pai até encontrar um que aponta para si mesmo, o qual é o representante do conjunto.

> **Função Find (Ingênua) - Código Simples**
> \pseudocodofindnaiveinlined

Na definição do Find, o processo que segue o ponteiro do nó pai até a raiz configura-se como a **busca ingênua**. Essa operação essencial tem complexidade $O(n)$, o que não é o ideal. Por isso, a operação Find possui formas de otimização \cite{chen2025hierarchical}:

*   **Path Compression:** cada nó pai aponta diretamente para a raiz da árvore.

> **Função Find (Otimizada com Path Compression)**
> \pseudocodofindoptimized

---

\section{OTIMIZAÇÃO DO DSU: COMPRESSÃO DE CAMINHO}

A **compressão de caminho** é a principal otimização utilizada no DSU para acelerar operações repetidas. A técnica consiste em "conectar nós diretamente ao seu nó raiz, reduzindo a altura da árvore ao mínimo" \cite{shen2023study}. A combinação desta otimização com Union by Rank/Size resulta em uma complexidade amortizada $O(\alpha(n))$ (função inversa de Ackermann), que é "efetivamente constante" \cite{griffiths2024union}.

Para evitar que as árvores cresçam demais, é realizado o uso de otimizações na união e busca:

\subsection{A. Union by size}

**Union by size (UBS)** sempre anexa a menor árvore à maior. Essa técnica "limita a altura das árvores a $O(\log n)$" e reduz o custo do find \cite{griffiths2024union}.

Ao unir dois conjuntos, a raiz da árvore menor é sempre ligada à raiz da árvore maior. Isso garante que a altura da árvore resultante cresça o mais lentamente possível. Um elemento só aumenta a sua profundidade se a sua árvore for ligada a uma maior, o que acontece no máximo $O(\log n)$ vezes.

\subsection{B. Path Compression}

**Path compression** comprime o caminho de busca tornando cada nó visitado filho direto da raiz.

\subsection{C. Path Splitting}

Patwary, Blair e Manne \cite{patwary2010experiments} discutem variantes que evitam uma segunda passagem pelos nós, sendo potencialmente mais eficientes. No **Path Splitting**, cada nó no caminho de busca é atualizado para apontar para o seu avô (o pai do seu pai). Isso encurta o caminho gradualmente sem a necessidade de conhecer a raiz antecipadamente.

\subsection{D. Path Halving}

Outra variação citada por Patwary, Blair e Manne \cite{patwary2010experiments} é a **Path Halving**. A atualização do ponteiro para o avô é feita em nós alternados (um nó sim, um nó não) ao longo do caminho, reduzindo pela metade a quantidade de gravações na memória, o que pode ser vantajoso em arquiteturas com barramentos de memória saturados.

\subsection{E. Union by rank}

**Union by Rank** é uma variação onde, em vez do tamanho exato, armazena-se um limite superior para a altura da árvore, chamado de "**posto**" (rank).

Se duas árvores de postos diferentes são unidas, a de menor posto é ligada à de maior posto, e o posto resultante não muda. Se duas árvores do mesmo posto são unidas, uma é ligada à outra e o posto da nova raiz é incrementado em 1. Sua vantagem é que ocupa menos memória que o tamanho (o posto nunca excede $\log N$).

---

\section{ANÁLISE BIBLIOMÉTRICA}

A revisão bibliométrica realizada na base de dados Web of Science (filtros: "disjoint set" e "computer science") revelou o seguinte panorama:

\subsection{A. Distribuição por Áreas de Pesquisa}

A pesquisa é fortemente concentrada em campos que unem a matemática à computação.

*   **Mathematics Applied:** 25 publicações.
*   **Computer Science Theory Methods:** 19 artigos.
*   **Mathematics:** 14 publicações.

Também há distribuição em Computer Science Software Engineering (11), Computer Science Artificial Intelligence (9), e Computer Science Information Systems (9).

\subsection{B. Tipologia dos Documentos Publicados}

Há uma prevalência clara de **Articles** (aproximadamente 57 publicações) em periódicos científicos, seguidos por **Proceedings Papers** (cerca de 18 publicações) em anais de conferências.

\subsection{C. Evolução Temporal da Produção Científica}

A análise temporal (2015-2025) mostra um interesse crescente. Um pico notável ocorreu nos anos de **2020 e 2021**, que juntos somam 13 publicações, possivelmente relacionado à demanda por algoritmos eficientes e ao aumento geral da produção científica. A relevância do tópico é contínua, com recuperação em 2023, 2024 e 2025.

\subsection{D. Ausência de Publicações em Português}

As buscas nas bases Scopus e Web of Science utilizando o termo em português "**conjuntos disjuntos**" **não retornaram resultados**. Isso reflete a natureza predominantemente anglófona da publicação científica na área, mas também sugere uma oportunidade para a produção de material educacional e científico em português sobre o tema.

---

\section{PROCESSAMENTO DE IMAGENS}

A estrutura Union-Find é ideal para o problema de **extrair as características principais de uma imagem** na área de visão computacional, pois gerencia coleções disjuntas de pixels que são agrupados (\textit{mesclados}) ao longo do tempo (crescimento de regiões).

Fiorio e Gusted \cite{fiorio1996linear} sugeriram dois algoritmos que garantem a linearidade das operações:

\begin{enumerate}
    \item **ScanLine:** Processa a imagem linha a linha, inspecionando cada pixel para determinar se ele pode ser integrado às regiões formadas pelos pixels adjacentes (esquerda e acima). O processo de União prioriza ligar a região mais recentemente encontrada àquela identificada primeiro, assumindo uma complexidade $O(1)$.
\item **MergeSquares:** Assume que a imagem é um quadrado de $2^k \times 2^k$ e procede recursivamente, dividindo-o em 4 sub-quadrados. Após a recursão, as regiões nos 4 sub-quadrados são fundidas ao longo da fronteira comum.
\end{enumerate}

> **Pseudocódigo do algoritmo ScanLine**
> \pseudocodoScanLine

> **Pseudocódigo do algoritmo MergeSquares**
> \pseudocodoMergeSquares

Allegretti, Bolelli e Grana \cite{allegretti2020optimized} sugeriram o "**Block-based Union Find kernels (BUF)**" para mitigar o problema de **acesso excessivo à memória** em GPUs. O BUF aplica o processamento a **blocos $2\times2$** em vez de pixels individuais e é implementado através de quatro \textit{kernels}:

1.  **INITIALIZATION:** Cada bloco começa como uma árvore separada (singleton).
2.  **MERGE:** Realiza a união entre blocos adjacentes conectados, utilizando operações atômicas para concorrência.
3.  **COMPRESSION:** Aplica a função \texttt{Compress} para achatar a árvore union-find, garantindo que todos os blocos do mesmo componente compartilhem o mesmo rótulo.
4.  **FINAL LABELING:** Copia os rótulos dos blocos para os pixels individuais de primeiro plano.

---

\section{ALGORITMO DE KRUSKAL}

Na Teoria dos Grafos, o Union-Find é crucial para o **Algoritmo de Kruskal**, usado para construir a **Árvore Geradora Mínima (MST)**, principalmente para **detectar ciclos em tempo quase constante**.

A operação do algoritmo de Kruskal envolve:
1. Ordenar todas as arestas do grafo por peso.
2. Iterar sobre as arestas, adicionando uma aresta à MST se, e somente se, seus vértices de extremidade pertencerem a componentes conectadas diferentes (verificado por \texttt{FIND-SET} e unido por \texttt{UNION}).

> **Pseudocódigo do Algoritmo de Kruskal**
> \pseudocodoKruskal

A complexidade geral do algoritmo é dominada pela ordenação das arestas, sendo tipicamente $O(|E| \log |E|)$ ou $O(|E| \alpha(|V|))$ \cite{chargueraud2019verifying}.

### Aplicações do Kruskal
*   **Computação Neuromórfica e Paralela:** Versões em pipeline, como o \texttt{NeuroSeqKruskal} \cite{chong2024pipelining}, adaptam-se a arquiteturas paralelas. Também é usado na construção de EMSTs e clustering hierárquico (HDBSCAN*).
*   **Geração Procedural de Labirintos:** Gera um labirinto "perfeito" (topologicamente equivalente a uma árvore geradora) ao adicionar arestas que não formam ciclos.
*   **Otimização Evolutiva (Generalised-Kruskal):** O framework \texttt{Generalised-Kruskal (GK)} \cite{bossek2024generalised} abstrai o mecanismo de construção de árvores para criar operadores de mutação para o problema da MST multi-objetivo (moMST).
*   **Planejamento de Redes e Clustering:** Aplicações diretas em projeto de redes de transporte e formação da base para o clustering de ligação única.

---

\section{CONCLUSÃO}

A estrutura de dados Conjuntos Disjuntos (DSU) é uma ferramenta algorítmica de relevância inegável na Ciência da Computação. Sua eficiência, viabilizada pela **Union by Rank/Size** e **Path Compression**, confere uma complexidade amortizada de $O(\alpha(n))$ (praticamente constante).

O DSU é indispensável tanto para algoritmos clássicos (como a detecção de ciclos no Algoritmo de Kruskal) quanto para soluções modernas de alto desempenho (como o algoritmo BUF para otimizar o acesso à memória em GPUs).

A análise bibliométrica revela a necessidade de pesquisa contínua em otimizações para novas arquiteturas de hardware (e.g., Path Splitting e Halving) e aponta a **oportunidade para a comunidade brasileira** de produzir conteúdo acadêmico e educacional em português sobre o tema, dada a lacuna identificada nas principais bases de dados internacionais.

\bibliographystyle{IEEEtran}
\bibliography{myrefs}

\end{document}
